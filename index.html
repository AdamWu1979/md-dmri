<html><head><title>MDM manual</title></head></body><pre><h1 style="background-color:black;color:white">Overview</h1><br><a href="#p1">Introduction</a>
<a href="#p2">acq/bruker</a>
<a href="#p3">mdm</a>
<a href="#p4">mio</a>
<a href="#p5">mio/elastix</a>
<a href="#p6">msf</a>
<a href="#p7">methods</a>
<a href="#p9">methods/dtd_pa</a>
<a href="#p10">methods/dti_euler</a>
<a href="#p11">methods/dti_nls</a>
<a href="#p12">methods/dtd_pake</a>
<a href="#p13">methods/fexi11</a>
<a href="#p14">methods/dtd_gamma</a>
<a href="#p15">methods/quick_dti</a>
<a href="#p16">methods/dtd_saupe</a>
<a href="#p17">methods/vasco16</a>
<a href="#p18">tools</a>
<a href="#p19">tools/tensor_maths</a>
<a href="#p20">tools/uvec</a>
<h1 id="p1" style="background-color:black;color:white">&nbsp;Package: .</h1>Multidimensional Diffusion MRI analysis framework (MD-MRI)<br>----------------------------------------------------------<br><br>Authors:<br>Markus Nilsson<br>Daniel Topgaard<br>Samo Lasic<br>Carl-Fredrik Westin<br><br>This package contains MATLAB files to help researchers analyze multi-<br>dimensional diffusion MRI data, for example, data acquired with<br>b-tensors of varying shape. If you find this code useful, please<br>provide feedback to markus.nilsson@med.lu.se. We appreciate your feedback.<br><br>The following MATLAB toolboxes are useful to get the code running properly: <br>- Optimization toolbox<br>- Image Processing toolbox<br><br>We envision the following usage scenario. The functions herein support <br>step 3 and 4.<br><br>1. Define an experiental protocol by selecting b-values, echo times, <br>   image resolution et c. <br><br>   Acquisition software for Bruker is found in acq/bruker. <br><br>   For implementations at Siemens and Philips, please contact us at <br>   markus.nilsson@med.lu.se to discuss research cooperations.<br><br>2. Run the protocol and acquire data in some native format, for example, <br>   DICOM. Unfortunately, all parameters needed to analyse the<br>   data may not be stored in the DICOM. For example, the mixing time in a<br>   FEXI experiment may not be in the DICOM header. The user need to find<br>   some way to connect this extra data to the image data. The fields needed<br>   for each model is listed in functions called *_check_xps.m, where<br>   here * is e.g. dti_nls, fexi, et c. <br><br>   Example: In FEXI, mixing times need to be entered manually <br>            as xps.mde_tm12 = [0.1 0.1 0.25];<br><br><br>3. Convert the data to the format supported in this framework. Image data<br>   in DICOM format is preferabbly converted by the dcm2nii utility<br>   https://www.nitrc.org/projects/dcm2nii/ <br><br>   To convert metadata such as b-values into our format, we supply<br>   functions to assist in this process under the 'multidimensional<br>   data management' (mdm) package. <br><br>   Example for a DTI-scan where gradient directions and b-values are stored<br>   in a gdir file (n_x, n_y, n_z, b)<br><br>        s.nii_fn = 'my_dti_scan.nii';<br>        s.xps    = mdm_xps_from_gdir('my_dti_scan_gdir.txt');<br><br>   The s-structure is now ready to enter a pipeline. The nii_fn points to <br>   the 4D image data file, and the xps structure contains the experiment <br>   parameters.<br><br>4. Execute a pipeline function. You find the pipelines under e.g. <br>   models/dti_nls/dti_nls_pipe_example.m. The naming convention here is<br>   that the prefix 'dti_nls' tells something about the model/fitting, and<br>   the suffix about what is being done. Example:<br><br>        dti_nls_pipe_example(s, output_path);<br><br>   The pipeline generates a .mat-file with a model-fit structure (mfs). <br>   This model-fit structure is generated by a function called e.g. <br>   *_4d_data2fit. The pipeline may include both masking and motion <br>   correction. Fitting will be performed in every voxel where the mask<br>   is non-zero. A manually defined mask can be supplied by setting <br>   s.mask_fn. In addition, opt.i_range, opt.j_range, and opt.k_range can <br>   be set to limit the loop to certain ranges in the first, second and third<br>   dimension of the image volume. In that case, the intersect of the mask <br>   and the x_range parameter will be used as the final mask.<br><br>   From the model-fit structure, several parameter volumes can be generated<br>   for further analysis. This is done using functions named e.g.<br>   *_4d_fit2param. A pipeline typically includes this as the last step.<br><br>5. Analyze the data, stored as nii-files by drawing ROIs or using other <br>   analysis packages of your choice.<br><br><br>We suggest you start analysing the model found in models/dti_nls to get<br>an understanding of the model structure.<br><h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function setup_paths(do_restore_path)</b><br><div style="color:black">% Restores the default paths and adds all relevant subdirs to the</div><div style="color:black">% path. Run this when you start MATLAB to use the code.</div><div style="color:black">%</div><div style="color:black">% do_restore_path - optional, defaults to true</div><br><h1 id="p2" style="background-color:black;color:white">&nbsp;Package: acq/bruker</h1>Pulse programs and Matlab files for acquiring and processing multidimensional dMRI on Bruker Avance spectrometers.<br><br>Written by Daniel Topgaard 20160427.<br>daniel.topgaard@fkem1.lu.se<br><br>Assumes familiarity with TopSpin and Matlab. <br><br>Acquisition<br> 2D single-shot imaging with axisymmetric diffusion encoding.<br> See fig 1 in Topgaard, Phys. Chem. Chem. Phys. 18, 8545 (2016),<br> http://dx.doi.org/10.1039/c5cp07251d.<br> RARE image read-out.<br> Hennig et al, Magn Reson Med. 3, 823 (1986),<br> http://dx.doi.org/10.1002/mrm.1910030602.<br><br>Processing<br>1) Conventional diffusion tensors;<br>    fractional anisotropy;<br>    Westin's shape indices.<br><br> 2) Isotropic and anisotropic variance of the diffusion tensor distribution;<br>    orientational order parameters;<br>    microscopic diffusion anisotropy.<br>    See Lasic et al, Front. Phys. 2, 11 (2014), <br>    http://dx.doi.org/10.3389/fphy.2014.00011.<br><br> 3) Shape of the microscopic diffusion tensor (prolate, sphere, oblate).<br>    See, Eriksson et al., J. Chem. Phys. 142, 104201 (2015),<br>    http://dx.doi.org/10.1063/1.4913502.<br><br> 4) Saupe order tensors.<br>    See Topgaard, Phys. Chem. Chem. Phys. 18, 8545 (2016),<br>    http://dx.doi.org/10.1039/c5cp07251d.<br><br> 5) Size-shape diffusion tensor distributions.<br>    See de Almeida Martins and Topgaard, Phys. Rev. Lett. 116, 087601 (2016).<br>    http://dx.doi.org/10.1103/PhysRevLett.116.087601.<br>   <br> 6) Size-shape-orientation diffusion tensor distributions.<br>    Work in progress<br><br><br>Two versions available:<br>1) Avance II TopSpin 2.1.<br>Tested on Bruker 500 MHz with MIC-5 probe at Physical Chemistry, Lund University.<br><br>2) Avance III HD TopSpin 3.2.<br>Tested on Bruker 600 MHz with MIC-5 probe at Swedish NMR Center, Gothenburg.<br>Does NOT work with TopSpin 3.5 because of a software bug causing uncontrolled scaling of the gradient waveforms (inquire with Klaus Zick when this bug will be fixed).<br><br><br>Procedure<br>0) Set up Matlab paths by executing setup_paths.m.<br><br>1) Copy pulse program DT_axderare2d from<br>../mdm_framework/mdm_topgaard/acq/bruker/Avance<version>/pulseprograms<br>to <br>/opt/topspin<version>/exp/stan/nmr/lists/pp/users.<br><br>2) Generate gradient waveforms and acquisition protocol with<br>bruker_axde_waveform.m and<br>bruker_axde_protocol.m.<br><br>3) Copy all gradient shape files g* from<br>../mdm_framework/mdm_topgaard/acq/bruker/Avance<version>/protocol<br>to<br>/opt/topspin<version>/exp/stan/nmr/lists/gp/users and<br>/opt/data/<user>/nmr/<dataset>/<expno>.<br><br>4) Set acquisition parameters according to the instructions in the pulse program or by copying the example data sets<br>../mdm_framework/examples/bruker_examples/Avance_III_HD/DTrare2d_setup or<br>../mdm_framework/examples/bruker_examples/Avance_II/DT_axderare2d_test.<br><br>5) zg (zero go: perform an acquisition)<br><br>6) Copy step1_recon_data.m and step2_run_analysis.m to<br>/opt/data/<user>/nmr/<dataset>/<expno>.<br><br>7) Execute step1_recon_data.m for image recon.<br><br>8) Execute step2_run_analysis.m for data processing.<br><br>9) Parameter maps in nifti and pdf format can be found in<br>/opt/data/<user>/nmr/<dataset>/<expno>/NII_RES/maps.<br><h1 id="p3" style="background-color:black;color:white">&nbsp;Package: mdm</h1>Multidimensional data management (MDM). This package contains functions<br>for building the local data structure.<br><br>We work with a structure often referred to as 's'. This structure has the <br>following fields<br><br>s.nii_fn  - full path to a nifti file<br>s.xps     - the eXperimental Parameter Structure<br>s.mask_fn - (optional) path to a nifti file with a 3D mask<br>               that determines which parts of the data that contains<br>               actual data and not just background <br><br>EXPERIMENTAL PARAMETER STRUCTURE (xps)<br><br>The xps has the following fields. All are in SI units. Not all fields must<br>be present. The model code checks that the necessary fields are present.<br><br>All parameters in the xps should be are stored as variables of size n x m, <br>where n is the number of image volumes and m is the number of parameters. <br>For example, a 30 direction DTI set with 6 b0 images would render an xps<br>with many fields, for example, a 'bt' field of size 36 x 6, where 36 <br>is the total number of images and 6 are the number of parameters required <br>to describe the b-tensor.<br><br>A) General parameters<br><br>- n:          number of images/signal values (fourth dimension). All <br>              parameters need to have n entries.<br><br>- t_ex:       cumulative time from start of the experiment to the time of <br>              the excitation pulse<br><br>- t_acq:      time from excitation to readout of echo, i.e., k = 0 <br>              (typically equals te in a SE sequence)<br><br>- intention:  a string that describes the intention of the experiment, <br>              for example<br>                - PGSE/DTI<br>                - DDE/uFA<br>                - Angular-DDE<br>                - FEXI<br><br>- slice_order: not yet defined <br><br>- a_ind:      Averaging index. After averaging (arithmetic or geometric),<br>              there will be max(a_ind) number of images left.<br><br>- s_ind:      Series index. Refers to data acquired in different series, <br>              for example, with different prescans (e.g. gain adjustment).<br>              Can also index acquisitions with different echo times et c.<br>              <br><br>Potentially but not necessarily automatically calculated:<br><br>- b_ind:      Indexes measurements according to total b-values<br><br>- bd_ind:     Indexes measurements according to b-anisotropy (b_delta)<br><br>- be_ind:     Indexes measurements according to b-asymmetry (b_eta)<br><br>- br_ind:     Indexes measurements according to b-tensor rotations<br><br><br><br>B) Parameters describing the total diffusion encoding effects<br><br>- b:          total b-value<br>- bt:         b-matrix, n x 6 (see tm_* for format)<br>- alpha:      flow compensation factor (see Ahlgren 16)<br>- alpha2:     flow attenuation factor (see Ahlgren 16)<br><br><br>i) Parameters derived automatically:<br><br>- bt2:        outer product of b-matrix (fourth order tensor)<br>- u:          symmetry axis of bt, n x 3<br><br>- b_delta:    anisotropy of b-tensor<br>- b_eta:      asymmetry of b-tensor<br>- b_s:        spherical component of b-tensor (Martins et al, PRL 16)<br>- b_p:        planar component of b-tensor (Martins et al, PRL 16)<br>- b_l:        linear component of b-tensor (Martins et al, PRL 16)<br><br>- b_paszz:    b-eigenvalue furthest from the mean ("symmetry axis").<br>- b_pasyy:    b-eigenvalue closest from the mean ("symmetry axis")<br>- b_pasxx:    b-eigenvalue that is not zz or yy (Eriksson et al, JCP 15)<br>- b_alpha:    Euler angle of the b-tensor, from LAB TO PAS<br>- b_beta:     Euler angle of the b-tensor<br>- b_gamma:    Euler angle of the b-tensor<br>    <br><br><br>ii) Fields needed where we have not yet decided on a format<br><br>- gradient waveform<br>- nex? number of averages per acquisition, or perhaps also noise sigma?<br><br><br><br><br>C) Diffusion-related parameters in a multiple diffusion encoding setting<br><br><br>i) The following parameters are valid for SDE, DDE et c<br><br>- mde_delta1, mde_delta2:            Duration of diffusion encoding <br>                                     gradients. <br>                                     Note: For SDE, we have only mde_delta1<br><br>- mde_capital_delta1, delta2, et c:  Time between leading edged of encoding<br>                                     gradients. For SDE, only <br>                                     mde_capital_delta1 is defined<br><br>- mde_ramp_time                      Assumed to be the same throughout<br><br>- mde_g1, mde_g2:                    n x 3 vector, gradient amplitude<br><br>Derived parameters:<br><br>- mde_q1, mde_q2, ...:               q-vectors<br>- mde_td1, mde_td2, ...:             Diffusion times<br><br><br>ii) Parameters valid only for DDE, TDE or more <br><br>- mde_tm12, mde_tm23, ...: diffusion-related mixing times between <br>                           diffusion-encoding block 1 and 2, block 2 and 3, <br>                           in a DDE, TDE, et c setting. In DDE-based FEXI, <br>                           we have only mde_tm1. <br><br>- mde_b1, mde_b2, ...:     b-value per block in a DDE, TDE et c sequence<br>- mde_bt1, mde_bt2, ...:   b-tensor per block in a DDE, TDE et c sequence<br><br><br>Optional, may be calculated automatically:<br><br>- mde_tm12_ind:            Index according to mixing times<br>- mde_b1_ind, mde_b2_ind:  Index according to b1-values, b2-values, ...<br><br><br>D) Relaxation parameters dealing with total relaxation weighting <br><br>- te: echo time, total time with T2 weighting from excitation to readout<br><br>- tm: mixing time, total time with T1 relaxation from excitation to <br>      readout<br><br>- ts: saturation recovery time, time between magnetization was zero and <br>      excitation<br><br>- ti: inversion time, time between inversion of magnetization and <br>      excitation<br><br>- tr: repetition time, time between excitations<br><br>In addition, we see the need for managing more complex sequence with<br>multiple RF pulses. We suggest to store such timings in fields called<br><br>- ste_tm: a vector of mixing times in a STE experiment<br><br>- ste_te: a vector of echo times in a STE experiment<br><br><h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function res = mdm_bruker_acqus2mat(data_path)</b><br><div style="color:black">% Read Bruker acquisition parameters in directory data_path</div><div style="color:black">% Includes acqus, acqu2s, and (if defined) vd, vc, vp, and fq1 lists.</div><div style="color:black">% Save experimental parameter structures NMRacqus and NMRacqu2s in</div><div style="color:black">% data_path.</div><br><b style="color:black">function xps = mdm_bruker_dt_axderare2d_acqus2xps(data_path, xps_fn)</b><br><div style="color:black">% Calculation of b-tensors for the Bruker pulse program DT_axderare2d</div><div style="color:black">% as used in Topgaard, Phys. Chem. Chem. Phys., 2016.</div><div style="color:black">% http://dx.doi.org/10.1039/c5cp07251d</div><div style="color:black">%</div><div style="color:black">% data_path: directory for gradient text files</div><div style="color:black">% xps_fn (optional) filename of xps</div><br><b style="color:black">function out_path = mdm_bruker_dt_rare2d_recon(data_path, out_path, rps, opt)</b><br><div style="color:black">% Recon images acquired with Bruker pulse sequence DT_axderare2d.</div><div style="color:black">%</div><div style="color:black">% Works in progress</div><br><b style="color:black">function mdm_bruker_dt_rare2d_ser2nii(data_path, nii_fn, rps)</b><br><div style="color:black">% image reconstruction from Bruker DT_**rare2d pulse programs</div><div style="color:black">% saves complex image as nifti file</div><div style="color:black">% image resolution in field n.pixdim in nifti header</div><div style="color:black">%</div><div style="color:black">% data_path: folder where the Bruker ser file is located</div><div style="color:black">% nii_fn: nifti file name (including complete path and extension)</div><div style="color:black">% rps: image recon parameters structure</div><div style="color:black">% rps.smooth : Gaussian smooting [m]</div><div style="color:black">% rps.npix.read : image size in read dimension</div><div style="color:black">% rps.npix.phase : image size in phase dimension</div><br><b style="color:black">function gamma = mdm_bruker_gamma(NMRacqus)</b><br><div style="color:black">% NMRacqus: Bruker acquistion parameter structure</div><div style="color:black">% NMRacqus.nuc1: nucleus in acquisiton channel 1</div><br><b style="color:black">function g = mdm_bruker_grad_read(fn)</b><br><div style="color:black">% Read Bruker gradient shape file.</div><div style="color:black">% fn:   file name </div><div style="color:black">% g:    column vector with gradient values</div><br><b style="color:black">function Gmax = mdm_bruker_maxgradient(NMRacqus)</b><br><div style="color:black">% NMRacqus: Bruker acquistion parameter structure</div><div style="color:black">% NMRacqus.probhd: probehead name</div><div style="color:black">% Max gradients for the Bruker imaging probes in Lund </div><br><b style="color:black">function [o_fn, tpm_fn] = mdm_coreg(i_fn, r_fn, p_fn, o_path, opt)</b><br><div style="color:black">% Coregisters input file 'i_fn' to reference 'r_fn' using elastix parameters</div><div style="color:black">% 'p_fn'. Saves the files to 'o_path' as 'o_fn'</div><div style="color:black">%</div><div style="color:black">% For details on motion correction, see</div><div style="color:black">% </div><div style="color:black">% Nilsson M, Szczepankiewicz F, van Westen D, Hansson O (2015) </div><div style="color:black">% Extrapolation-Based References Improve Motion and Eddy-Current </div><div style="color:black">% Correction of High B-Value DWI Data: Application in Parkinson's </div><div style="color:black">% Disease Dementia. PLoS One 10(11):e0141825.</div><br><b style="color:black">function mfs_fn = mdm_data2fit(fun_4d_data2fit, s, mfs_fn, opt)</b><br><div style="color:black">% fun_4d_data2fit - model fit function</div><div style="color:black">% s               - input data structure</div><div style="color:black">% mfs_fn          - the model fit structure is written to mfs_fn</div><div style="color:black">% opt             - options structure</div><br><b style="color:black">function dps = mdm_dps_load(dps_fn)</b><br><div style="color:black">% load the derived parameter structure and check a few things</div><br><b style="color:black">function dps_fn = mdm_dps_save(dps, s, dps_fn, opt)</b><br><div style="color:black">% Saves derived parameter structure</div><br><b style="color:black">function status = mdm_fit(varargin)</b><br><div style="color:black">% initiate</div><br><b style="color:black">function dps_fn = mdm_fit2param(fun_4d_fit2param, mfs_fn, dps_fn, opt)</b><br><div style="color:black">% fun_4d_fit2param - parameter derivation function</div><div style="color:black">% mfs_fn           - model fit structure read from dps_fn</div><div style="color:black">% dps_fn           - derived parameter structure is written to dps_fn</div><div style="color:black">% opt              - options structure</div><br><b style="color:black">function gdir_fn = mdm_fn_nii2gdir(nii_fn)</b><br><div style="color:black">% convert a filename ending in .nii or .nii.gz to one ending in _gdir.txt</div><br><b style="color:black">function g = mdm_gwf_read(gwf_fn)</b><br><div style="color:black">% Read a gradient waveform</div><br><b style="color:red">function [bt, q] = mdm_gwf_to_btensor(gwf, dt, g_max)</b> (mdm_gwf_to_btensor.m)<br><div style="color:black">% assume max(abs(gwf)) = 1</div><br><b style="color:black">function o = mdm_iter_lund(input_path, f_handle, f_args, opt)</b><br><br><b style="color:black">function s = mdm_mask(s, mask_fun, path, opt)</b><br><div style="color:black">% Mask the data in s.nii_fn using mask_fun (e.g. mio_mask_simple)</div><div style="color:black">%</div><div style="color:black">% Save the mask as a nifti to s.mask_fn. This field is created if it does</div><div style="color:black">% not exist already</div><div style="color:black">% init</div><br><b style="color:black">function M = mdm_mask_load(s, opt)</b><br><div style="color:black">% Load the mask from s.mask_fn</div><div style="color:black">%</div><div style="color:black">% Optionally, mask using i_range, j_range and k_range in opt</div><br><b style="color:black">function mdm_mat2nii(I, path, sdim)</b><br><div style="color:black">% Makes nifti from I using path and header h</div><br><b style="color:black">function s = mdm_mec_b0(s, p_fn, o_path, opt)</b><br><div style="color:black">% Perform motion and eddy currect correction by registering to b0</div><div style="color:black">%</div><div style="color:black">% s      - input structure OR a nii_fn with xps computed from it</div><div style="color:black">% p_fn   - parameter filename, to elastix registration scheme</div><div style="color:black">% o_path - output path for the new files</div><div style="color:black">% opt    - options (optional)</div><div style="color:black">%</div><div style="color:black">% Output</div><div style="color:black">% s - s.nii_fn will be updated to refer to the corrected volume</div><br><b style="color:black">function s = mdm_mec_eb(s_target, s_source, p_fn, o_path, opt)</b><br><div style="color:black">% Perform motion and eddy currect correction by registering to extrapolated</div><div style="color:black">% references</div><div style="color:black">%</div><div style="color:black">% s_target  - input structure for target data OR a nifti filename</div><div style="color:black">% s_source  - input structure for source data (should be low b-values) </div><div style="color:black">%                               OR a nifti filename</div><div style="color:black">% p_fn      - parameter filename, to elastix registration scheme</div><div style="color:black">% o_path    - output path for the new files</div><div style="color:black">% opt       - options (optional)</div><div style="color:black">%</div><div style="color:black">% Output</div><div style="color:black">% s - s.nii_fn will be updated to refer to the corrected volume</div><div style="color:black">% init</div><br><b style="color:black">function mfs = mdm_mfs_load(mfs_fn)</b><br><div style="color:black">% Load model fit structure</div><br><b style="color:black">function mfs_fn = mdm_mfs_save(mfs, s, mfs_fn, opt)</b><br><div style="color:black">% Saves the model fit structure</div><br><b style="color:black">function mdm_nii2pdf(nii_fn, pdf_fn, opt)</b><br><div style="color:black">% Converts one or several nii files in nii_fn to pdf files</div><br><b style="color:black">function datatype = mdm_nii_datatype(value, t)</b><br><div style="color:black">% Returns the datatype of a nifti based on the header info in a </div><div style="color:black">% matlab-friendly format</div><div style="color:black">%</div><div style="color:black">% set t = 1 to change float64 --> double and float32 --> single</div><br><b style="color:black">function [nii_fn, tmp_path, tmp_fn] = mdm_nii_gunzip(nii_fn, h_only)</b><br><div style="color:black">% Extract the file to the system tempdir (faster if using an external HD)</div><br><b style="color:black">function h = mdm_nii_h_empty()</b><br><div style="color:black">% create a header where all apppropriate fields for the nifti header exists</div><br><b style="color:black">function out_nii_fn = mdm_nii_merge(nii_fn_cell, out_nii_fn, opt)</b><br><br><b style="color:black">function o = mdm_nii_oricode(h)</b><br><div style="color:black">% Find the principal orientation of the nifti header</div><br><b style="color:black">function [I,h] = mdm_nii_read(nii_fn)</b><br><br><b style="color:black">function [I,h] = mdm_nii_read_and_rescale(nii_fn)</b><br><br><b style="color:black">function h = mdm_nii_read_header(nii_fn)</b><br><div style="color:black">% Possibly unzip the file</div><br><b style="color:red">function out_fn = mdm_nii_subsample(in_fn, ind, out_fn)</b> (mdm_nii_subsample.m)<br><br><b style="color:black">function s = mdm_nii_to_s(nii_fn)</b><br><div style="color:black">% converts a nii_fn to an input structure with two fields</div><div style="color:black">%</div><div style="color:black">% s.nii_fn</div><div style="color:black">% s.xps</div><div style="color:black">%</div><div style="color:black">% assumes the xps filename can be constructred from the nii_fn</div><br><b style="color:black">function mdm_nii_write(I, nii_fn, h, is_colour)</b><br><br><b style="color:black">function opt = mdm_opt(opt)</b><br><div style="color:black">% Specifies default options </div><br><b style="color:black">function [a_ind, c_list, id_ind] = mdm_pa_ind_from_xps(xps)</b><br><div style="color:black">% Volumes with identical rotations is defined from xps.a_ind</div><div style="color:black">%</div><div style="color:black">% If this does not exist, we try to compute it, but beware of errors in</div><div style="color:black">% this step</div><br><b style="color:black">function [nii_fn, xps] = mdm_par2nii_and_xps(par_fn, nii_fn)</b><br><br><b style="color:black">function fn = mdm_param2nii(dps_fn, o_path, fig_opt, opt)</b><br><br><b style="color:black">function paths = mdm_paths(tmp, prefix, suffix)</b><br><div style="color:black">% paths will get the required fields:</div><div style="color:black">% paths.(mfs_fn/dps_fn/nii_path)</div><div style="color:black">%</div><div style="color:black">% if tmp is a string, these will be created assuming tmp is a path to the</div><div style="color:black">% folder where the mfs, dps and nii:s are going to be stored</div><div style="color:black">%</div><div style="color:black">% if tmp is a struct, we verify that these fields are present</div><br><b style="color:black">function xps = mdm_philips_fexi_prot2xps(prot_fn, xps)</b><br><div style="color:black">% Parse a Philips protocol text file in prot_fn, and store it in an xps</div><div style="color:black">%</div><div style="color:black">% The protocol file must have been generated with the FEXI patch</div><div style="color:black">%</div><div style="color:black">% An xps must be provided and some fields must have been filled in </div><div style="color:black">% (see this file for details)</div><div style="color:black">% associate tm so different s_ind's</div><br><b style="color:black">function s_protocol = mdm_philips_parse_txt_protocol(prot_fn)</b><br><br><b style="color:black">function s = mdm_powder_average(s, o_path, opt)</b><br><div style="color:black">% Average over rotations. Image volumes with identical rotations is defined</div><div style="color:black">% from s.xps.a_ind</div><div style="color:black">%</div><div style="color:black">% To do: find a way of keeping track of number of averages per step</div><div style="color:black">% Init</div><br><b style="color:black">function s = mdm_s_from_lund_nii_plus_gdir(nii_fn)</b><br><br><b style="color:black">function s_new = mdm_s_subsample(s, ind, path, opt)</b><br><br><b style="color:black">function s = mdm_smooth(s, filter_sigma, o_path, opt)</b><br><br><b style="color:red">function txt = mdm_txt_read(txt_fn, opt)</b> (mdm_txt_read.m)<br><div style="color:black">% This function returns each line in txt_fn as a cell, skipping empty</div><div style="color:black">% lines and those starting with #</div><div style="color:black">%</div><br><b style="color:black">function txt = mdm_txt_write(txt, txt_fn, opt)</b><br><div style="color:black">% This function write each line in txt, a cell, as separate lines in txt_fn</div><br><b style="color:black">function res = mdm_unix2txt(in_fn, out_fn)</b><br><div style="color:black">% Converts the unix text file 'in_fn' to the text file</div><div style="color:black">% 'out_fn'. If 'out_fn' is omitted, the original file is</div><div style="color:black">% overwritten. res = 1 in case of success.</div><div style="color:black">% Open the files</div><br><b style="color:black">function xps = mdm_xps_calc_btpars(xps)</b><br><br><b style="color:black">function mdm_xps_check(xps)</b><br><div style="color:black">% Check that necessary fields are present in the xps, and that all other</div><div style="color:black">% fields are well formatted</div><br><b style="color:black">function xps_fn = mdm_xps_fn_from_nii_fn(nii_fn)</b><br><br><b style="color:black">function xps = mdm_xps_from_bt(bt)</b><br><br><b style="color:black">function xps = mdm_xps_from_btens(btens_fn)</b><br><div style="color:black">% assume b-tensors are stored in a file where each row corresponds to a</div><div style="color:black">% b-tensor in voigt format, i.e.</div><div style="color:black">%</div><div style="color:black">% b_xx b_yy b_zz sqrt(2) * b_xy sqrt(2) * b_xz sqrt(2) * b_yz</div><div style="color:black">%</div><div style="color:black">% see tm_1x3_to_1x6.m and tm_1x6_to_3x3.m for conversion between tensors</div><div style="color:black">% on 3x3 or 1x6 (voigt) format.</div><br><b style="color:red">function xps = mdm_xps_from_bval_bvec(bval_fn, bvec_fn, b_delta)</b> (mdm_xps_from_bval_bvec.m)<br><br><b style="color:black">function xps = mdm_xps_from_gdir(gdir_fn, delimeter, b_delta)</b><br><div style="color:black">% read a gradient textfile in the Lund format, which is defined as follows</div><div style="color:black">%   n_x, n_y, n_z, b</div><div style="color:black">% </div><div style="color:black">% units of b are in s/mm2, i.e., b = 1000 s/mm2 for a standard DTI</div><div style="color:black">%</div><div style="color:black">% the xps is always in SI units</div><div style="color:black">%</div><div style="color:black">% optional arguments</div><div style="color:black">% delimeter, asumed to be ',' unless specified</div><div style="color:black">% b_delta, assumed to be 1 unless specified (e.g. PGSE / LTE / SDE)</div><br><b style="color:black">function xps = mdm_xps_load(xps_fn)</b><br><br><b style="color:black">function xps = mdm_xps_merge(xps_cell, opt)</b><br><div style="color:black">% xps_cell could be a cell of xps structres or filenames</div><br><b style="color:red">function xps_pa = mdm_xps_pa(xps, opt)</b> (mdm_xps_pa.m)<br><br><b style="color:red">function mdm_xps_save(xps, xps_fn, opt)</b> (mdm_xps_save.m)<br><br><b style="color:black">function xps = mdm_xps_subsample(xps, ind)</b><br><div style="color:black">% help the user</div><br><b style="color:black">function fn = ut_mdm(c_ut)</b><br><div style="color:black">% Run unit tests on the files in this package</div><br><h1 id="p4" style="background-color:black;color:white">&nbsp;Package: mio</h1>Multidimensional Image Operations (MIO)<br><br>Functions for manipulating image volumes. These functions should take an <br>image volume (3D or 4D) as first input and yield another image volume as<br>the first output<br><br><h2 style="background-color:#dddddd">Functions</h2><b style="color:red">function [I_res,tp,h_res,elastix_t] = mio_coreg(I_mov, I_ref, p, opt, h_mov, h_ref)</b> (mio_coreg.m)<br><br><b style="color:black">function mfs_fn = mio_fit_model(fun, s, o_fn, opt)</b><br><div style="color:black">% Fits the model specified in 'fun' to the data referred to in 's', </div><div style="color:black">% and saves the output in 'o_fn', which should have '.mat' as its extension</div><div style="color:black">%</div><div style="color:black">% Typically, 'fun' is a local function defined within model_4d_data2fit</div><br><b style="color:black">function M = mio_mask_cv(I, opt)</b><br><div style="color:black">% all images should have the same contrast</div><div style="color:black">% </div><br><b style="color:red">function M = mio_mask_expand(I, n, opt)</b> (mio_mask_expand.m)<br><div style="color:black">% expand the mask by n voxels</div><br><b style="color:black">function M = mio_mask_fill(M,d)</b><br><div style="color:black">% fill holes in a mask on a slice-by-slice basis</div><br><b style="color:black">function M = mio_mask_keep_largest(M)</b><br><br><b style="color:black">function M = mio_mask_mic(I, opt)</b><br><br><b style="color:black">function M = mio_mask_pca(I, opt)</b><br><div style="color:black">% pca-based filtering, inspired by an MRM paper (to do: find ref)</div><br><b style="color:black">function M = mio_mask_simple(I, opt)</b><br><div style="color:black">% creates a mask in a very simple way by looking a signal variation along</div><div style="color:black">% the fourth dimension</div><div style="color:black">% define the mask from the variation of the signal</div><br><b style="color:black">function M = mio_mask_thresh(I, opt)</b><br><br><b style="color:black">function I = mio_min_max_cut(I, min_max)</b><br><div style="color:black">% cut values below min or above max, where [min max] = min_max</div><br><b style="color:black">function opt = mio_opt(opt)</b><br><br><b style="color:black">function A = mio_pa(I, xps, opt)</b><br><br><b style="color:black">function I = mio_pad(I, pad_xyz)</b><br><div style="color:black">% Adds zero around 'I' according to the three numbers in 'pad_xyz', </div><div style="color:black">% which may be negative (this leads to trimming instead)</div><br><b style="color:black">function I_ref = mio_ref_extrapolate(I, xps_source, xps_target, M, ind)</b><br><div style="color:black">% Extrapolate references according to Nilsson et al, 2015, Plos One </div><div style="color:black">% doi:10.1371/journal.pone.0141825</div><br><b style="color:black">function [I_B,sc] = mio_rescale(I_B, I_A, M)</b><br><div style="color:black">% rescale B to A</div><br><b style="color:black">function I = mio_smooth_4d(I, filter_sigma, opt)</b><br><div style="color:black">% Gaussian smoothing with a width controlled by 'filter_sigma'</div><div style="color:black">% init </div><br><b style="color:black">function I_out = mio_transform(I_in, t, h, opt)</b><br><div style="color:black">% I: Image volume (x,y,z,c) to be transformed (looping over 4th dim)</div><div style="color:black">% t: Elastix Transform structure</div><div style="color:black">% h: Nifti header</div><div style="color:black">%</div><div style="color:black">% Note that the contents of h and t must be matched</div><br><b style="color:black">function p = mio_volume_loop(fun, I, M, opt, S)</b><br><div style="color:black">% Applies the function fun to all voxels where M is positive</div><div style="color:black">%</div><div style="color:black">% In order to execute the loop in parallel, initiate parpool before</div><div style="color:black">% executing this function. If number of workers > 1, volume loop will be</div><div style="color:black">% executed in parallel</div><div style="color:black">%</div><div style="color:black">% fun - accepts one or two input arguments (signal vector + optionally</div><div style="color:black">%          supplementary data)</div><div style="color:black">%</div><div style="color:black">% I   - 4D matrix</div><div style="color:black">% </div><div style="color:black">% M   - 3D mask</div><div style="color:black">%</div><div style="color:black">% opt - option structure</div><div style="color:black">%</div><div style="color:black">% S   - 4D supplementary data</div><br><b style="color:black">function fn = ut_mio(c_ut)</b><br><div style="color:black">% Run unit tests on the files in this package</div><br><h1 id="p5" style="background-color:black;color:white">&nbsp;Package: mio/elastix</h1>These functions allows for interaction with the ElastiX program for<br>image registration. <br><br>To get ElastiX running, follow these instructions<br><br><br>1) Download ElastiX from http://elastix.isi.uu.nl<br><br>2) Unzip and rename the downloaded folder as 'elastix'<br><br>MAC<br><br>3) Move the program folder into /usr/local/elastix, e.g. by<br>    'sudo mv ~/Downloads/elastix /usr/local'<br><br>4) Typing 'ls /usr/local/elasmtix' should now show to folder, bin and lib<br> <br>5) To run, you need to be able to start elastix from your terminal by <br>   typing 'elastix'. Do this by editing ~/.bash_profile, and add the following<br>   lines <br><br>   export PATH=/usr/local/elastix/bin:/usr/local/elastix/parameters:$PATH<br>   export DYLD_LIBRARY_PATH=/usr/local/elastix/lib:$DYLD_LIBRARY_PATH<br><br>   The editing can be done from within Matlab by <br>   typing 'edit ~./bash_profile'<br>  <br><br>WINDOWS<br><br>3) Move the program folder into <h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function p = elastix_p_3dof(n_iter)</b><br><div style="color:black">% Use an affine transform, but with all parameters except </div><div style="color:black">% translation x, y and rotation around z set to zero</div><br><b style="color:black">function p = elastix_p_6dof(n_iter)</b><br><div style="color:black">% Use an affine transform, but with all parameters except </div><div style="color:black">% translation x, y and rotation around z set to zero</div><br><b style="color:black">function p = elastix_p_affine(n_iter)</b><br><br><b style="color:black">function p = elastix_p_read(fn)</b><br><div style="color:black">% Reads an elastix parameter structure from file</div><br><b style="color:black">function fn = elastix_p_write(p, fn)</b><br><div style="color:black">% Writes the elastix parameter structure to a file</div><br><b style="color:black">function [res_fn, tp_fn] = elastix_run_elastix(i_fn, ref_fn, p_fn, o_path)</b><br><div style="color:black">% Runs elastix. For help, see readme.txt in the elastix folder.</div><br><b style="color:black">function res_fn = elastix_run_transformix(i_fn, t_fn, o_path)</b><br><div style="color:black">% Run transformix. For help, see readme.txt in the elastix folder.</div><br><b style="color:black">function [p,tmat,str] = elastix_tp_read(fn)</b><br><div style="color:black">% Reads a transform parameter file</div><div style="color:black">% Read the whole file</div><br><b style="color:black">function tpm = elastix_tpm_read(tpm_fn)</b><br><div style="color:black">% Read a set of transform parameters from the Affine DTI Transform</div><div style="color:black">%</div><div style="color:black">% </div><br><b style="color:black">function elastix_tpm_write(tpm, fn)</b><br><div style="color:black">% Writes the 'transform parameter matrix' to the file named 'fn'</div><br><h1 id="p6" style="background-color:black;color:white">&nbsp;Package: msf</h1>Multidimensional support functions (msf). Functions that help with everyday<br>things...<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function gamma = msf_const_gamma(nucleus)</b><br><br><b style="color:black">function msf_delete(fn)</b><br><div style="color:black">% Deletes the file fn, or multiple files if fn is a cell array</div><br><b style="color:black">function s = msf_ensure_field(s, f, v)</b><br><div style="color:black">% Sets the field 'f' in the structure 's' to the value 'v', unless there is</div><div style="color:black">% already a field 'f' in 's'.</div><br><b style="color:black">function [path, name, ext] = msf_fileparts(fn)</b><br><div style="color:black">% Just as the built-in 'fileparts', except that this run fileparts twice in</div><div style="color:black">% order to count '.nii.gz' as one extension</div><br><b style="color:black">function [t,ss] = msf_fit(f, s, l, u, n, opt)</b><br><div style="color:black">% Perform lsqcurvefit with function 'f' on data 's', repeating it 'n' times</div><div style="color:black">%</div><div style="color:black">% f - function handle</div><div style="color:black">% s - signal</div><div style="color:black">% l - lower bound</div><div style="color:black">% u - upper bound</div><div style="color:black">% n - number of repetitions</div><div style="color:black">% opt - options for lsqcurvefit</div><br><b style="color:black">function msf_fprintf(opt, str, varargin)</b><br><div style="color:black">% prints to terminal if opt.verbose = 1</div><br><b style="color:black">function msf_imagesc(I,d,k,c)</b><br><div style="color:black">% Displays a 2D slice through a 3D or 4D image volume I</div><div style="color:black">%</div><div style="color:black">% d - dimension</div><div style="color:black">% k - slice</div><div style="color:black">% c - volume</div><br><b style="color:black">function val = msf_isfield(s, field_name)</b><br><br><b style="color:black">function msf_log(str, opt)</b><br><div style="color:black">% Displays 'str' if opt.verbose is true</div><br><b style="color:black">function msf_mkdir(folder_path)</b><br><div style="color:black">% Recursively makes folder_path</div><br><b style="color:black">function a = msf_nanmean(a,d)</b><br><br><b style="color:black">function s = msf_rmfield(s, f)</b><br><div style="color:black">% Removes field 'f' from 's' is possible. If 'f' is a cell array, all</div><div style="color:black">% fields in 'f' are removed</div><br><b style="color:black">function sz = msf_size(m, d)</b><br><div style="color:black">% a size function that makes sure to return data with the correct</div><div style="color:black">% dimensionality</div><div style="color:black">%</div><div style="color:black">% m - matrix</div><div style="color:black">% d - dimensions, i.e. length of sz</div><br><b style="color:black">function o = msf_str2double(str, delim)</b><br><div style="color:black">% Splits 'str' according to 'delim' and converts to double</div><br><b style="color:black">function tmp_path = msf_tmp_path(do_mkdir)</b><br><div style="color:black">% Obtains a temporary path with a random name</div><br><h1 id="p7" style="background-color:black;color:white">&nbsp;Package: methods</h1>Collection of models for multidimensional diffusion MRI<h1 id="p9" style="background-color:black;color:white">&nbsp;Package: methods/dtd_pa</h1>Diffusion tensor distribution from powder averaged data by Topgaard.<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = dtd_pa_1d_data2fit(signal, xps, opt, ind)</b><br><div style="color:black">% Size-shape diffusion tensor distribution</div><div style="color:black">% Assumes powder averaging</div><div style="color:black">% de Almeida Martins and Topgaard, Phys. Rev. Lett. 116, 087601 (2016).</div><div style="color:black">% http://dx.doi.org/10.1103/PhysRevLett.116.087601</div><div style="color:black">% Modified for general b-tensor shapes</div><br><b style="color:red">function s = dtd_pa_1d_fit2data(m, xps)</b> (dtd_pa_1d_fit2data.m)<br><br><b style="color:red">function res = dtd_4d_data2fit(s, mfs_fn, opt)</b> (dtd_pa_4d_data2fit.m)<br><br><b style="color:black">function dps = dtd_pa_4d_fit2param(mfs_fn, dps_fn, opt)</b><br><br><b style="color:red">function dtd = dtd_pa_data2dtd(stemp,b,b_delta,dtd_nodes)</b> (dtd_pa_data2dtd.m)<br><br><b style="color:red">function dtd_nodes = dtd_pa_dist2nodes(dtd)</b> (dtd_pa_dist2nodes.m)<br><br><b style="color:red">function [n,par,perp,w] = dtd_pa_dist2par(dtd_pa)</b> (dtd_pa_dist2par.m)<br><br><b style="color:red">function m = dtd_pa_dtd2m(dtd,opt)</b> (dtd_pa_dtd2m.m)<br><br><b style="color:black">function dtd = dtd_pa_extinction(stemp, b, b_delta, dtd, opt)</b><br><br><b style="color:red">function dtd_pa = dtd_pa_m2dtd(m)</b> (dtd_pa_m2dtd.m)<br><br><b style="color:black">function dtd_pa_mkpdf(dps_fn, pdf_path, opt)</b><br><br><b style="color:red">function [n,par,perp] = dtd_pa_nodes2par(dtd_nodes)</b> (dtd_pa_nodes2par.m)<br><br><b style="color:red">function dtd_nodes = dtd_pa_nodes_merge(dtd_nodes1,dtd_nodes2)</b> (dtd_pa_nodes_merge.m)<br><br><b style="color:red">function dtd_nodes_out = dtd_pa_mutate(dtd_nodes,opt)</b> (dtd_pa_nodes_mutate.m)<br><br><b style="color:red">function dtd_nodes_out = dtd_pa_nodes_select(dtd_nodes,ind)</b> (dtd_pa_nodes_select.m)<br><br><b style="color:red">function dtd = dtd_pa_nodesw2dist(dtd_nodes,w)</b> (dtd_pa_nodesw2dist.m)<br><br><b style="color:black">function opt = dtd_pa_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dtd_pa_pipe(s, paths, opt)</b><br><div style="color:black">% s     - input structure</div><div style="color:black">% paths - either a pathname or a path structure (see mdm_paths)</div><div style="color:black">% opt   - (optional) options that drive the pipeline</div><div style="color:black">%</div><div style="color:black">% fn    - a cell arary with filenames to generated nii files</div><br><b style="color:red">function dtd_pa_plot(m, opt)</b> (dtd_pa_plot.m)<br><br><b style="color:red">function dtd = dtd_pa_proliferation(stemp, b, b_delta, opt)</b> (dtd_pa_proliferation.m)<br><br><b style="color:red">function dtd_nodes = dtd_pa_rand(n,dmin,dmax)</b> (dtd_pa_rand.m)<br><br><b style="color:red">function dtd_out = dtd_pa_sort(dtd_in)</b> (dtd_pa_sort.m)<br><br><h1 id="p10" style="background-color:black;color:white">&nbsp;Package: methods/dti_euler</h1>Diffusion tensor imaging with the diffusion tensor represented by<br>euler angles. Fitting is done in a weighted mannor to reduce influence of<br>high b-values.<br><br>By Topgaard.<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = dti_euler_1d_data2fit(signal, xps, opt, ind)</b><br><br><b style="color:black">function s = dti_euler_1d_fit2data(m, xps)</b><br><div style="color:black">% convert to readable parameters</div><br><b style="color:red">function mfs_fn = dti_euler_4d_data2fit(s, mfs_fn, opt)</b> (dti_euler_4d_data2fit.m)<br><br><b style="color:black">function dps = dti_euler_4d_fit2param(mfs_fn, dps_fn, opt)</b><br><br><b style="color:red">function dti_euler_mic_check_xps(xps)</b> (dti_euler_check_xps.m)<br><div style="color:black">% checks that all required fields are found in the xps</div><br><b style="color:black">function opt = dti_euler_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dti_euler_pipe(s, paths, opt)</b><br><div style="color:black">% s     - input structure</div><div style="color:black">% paths - either a pathname or a path structure (see mdm_paths)</div><div style="color:black">% opt   - (optional) options that drive the pipeline</div><div style="color:black">%</div><div style="color:black">% fn    - a cell arary with filenames to generated nii files</div><br><h1 id="p11" style="background-color:black;color:white">&nbsp;Package: methods/dti_nls</h1>A simple DTI model with NLS fitting. Utilizes Cholesky decomposition to <br>ensure positive eigenvalues of the diffusion tensor<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = dti_nls_1d_data2fit(signal, xps, opt)</b><br><div style="color:black">% Yields a 1x7 vector 'm' with the fit parameters</div><div style="color:black">% m(1)   - s0</div><div style="color:black">% m(2:7) - diffusion tensor</div><div style="color:black">%</div><div style="color:black">% This file features a number of functions important for this framework. </div><div style="color:black">% As input to the lsqcurvefit, we use a local vector t. Locally and during</div><div style="color:black">% the fit, we represent the diffusion tensor by its cholesky factorization</div><div style="color:black">% to ensure that all eigenvalues are positive. We also make sure the units</div><div style="color:black">% of 't' are in the same range as 's0' in order to improve the fitting's</div><div style="color:black">% stop constrains. Conversion between local 't' and true model variables</div><div style="color:black">% 'm' are done by the function 't2m'. </div><br><b style="color:black">function s = dti_nls_1d_fit2data(m, xps)</b><br><div style="color:black">% Predict the signal 's' as a 1 x xps.n vector from the model parameters</div><div style="color:black">% in 'm'. </div><br><br><b style="color:black">function mfs_fn = dti_nls_4d_data2fit(s, o, opt)</b><br><div style="color:black">% Loops over a 4D volume to produce fit parameters with the DTI nls model</div><div style="color:black">%</div><div style="color:black">% Input: </div><div style="color:black">%</div><div style="color:black">% s   - data structure</div><div style="color:black">%          s.nii_fn - full path to nifti filename with data</div><div style="color:black">%          s.xps    - experimental parameter structure</div><div style="color:black">%</div><div style="color:black">% o   - output folder   </div><div style="color:black">% </div><div style="color:black">% opt - options structure, optional</div><div style="color:black">%</div><div style="color:black">% Output:</div><div style="color:black">%</div><div style="color:black">% mfs_fn - path to .mat file with the ModelFitStructure (mfs)</div><br><b style="color:black">function fn = dti_nls_4d_fit2param(mfs_fn, o_path, opt)</b><br><div style="color:black">% Creates meaningful parameters from the model fit structure</div><div style="color:black">%</div><div style="color:black">% Input:</div><div style="color:black">%</div><div style="color:black">% mfs_fn - Path to .mat file with model fit structure</div><div style="color:black">%</div><div style="color:black">% o_path - Output path, where parameters maps are stored</div><div style="color:black">%</div><div style="color:black">% opt    - Options, optional argument</div><div style="color:black">%</div><div style="color:black">%</div><div style="color:black">% Output:</div><div style="color:black">%</div><div style="color:black">% fn     - A cell array with paths to parameter maps that were written</div><br><b style="color:black">function dti_nls_check_xps(xps)</b><br><div style="color:black">% checks that all required fields are found in the xps</div><br><b style="color:black">function opt = dti_nls_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dti_nls_pipe_example(s, o_path, opt)</b><br><div style="color:black">% s      - input structure</div><div style="color:black">% o_path - output path</div><br><b style="color:black">function fn = dti_nls_pipe_mic(s, o_path, opt)</b><br><div style="color:black">% s      - input structure</div><div style="color:black">% o_path - output path</div><div style="color:black">%</div><div style="color:black">% Pipeline for running dti_nls in a microimaging setting</div><br><b style="color:black">function fn = ut_dti_nls(c_ut)</b><br><div style="color:black">% if c_ut is not supplied, the function returns the number of unit tests</div><div style="color:black">% n_ut = number of unit tests</div><br><h1 id="p12" style="background-color:black;color:white">&nbsp;Package: methods/dtd_pake</h1>Estimate microscopic anisotropy by utilizing the dtd_pake model. <br><br>Assumes powder averaging and axisymmetric b-tensors<br><br>Eriksson et al., J. Chem. Phys. 142, 104201 (2015).<br>http://dx.doi.org/10.1063/1.4913502<br><h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = dtd_pake_1d_data2fit(signal, xps, opt, ind)</b><br><br><b style="color:black">function s = dtd_pake_1d_fit2data(m, xps)</b><br><div style="color:black">% m = [s0 d_iso d_delta]</div><div style="color:black">% convert to readable parameters</div><br><b style="color:red">function msf_fn = dtd_pake_4d_data2fit(s, mfs_fn, opt)</b> (dtd_pake_4d_data2fit.m)<br><div style="color:black">% Error function fit</div><div style="color:black">% Assumes powder averaging and axisymmetric b-tensors</div><div style="color:black">% Eriksson et al., J. Chem. Phys. 142, 104201 (2015).</div><div style="color:black">% http://dx.doi.org/10.1063/1.4913502</div><br><b style="color:red">function dps = dtd_pake_4d_fit2param(mfs_fn, dps_fn, opt)</b> (dtd_pake_4d_fit2param.m)<br><br><b style="color:black">function dtd_pake_check_xps( xps )</b><br><br><b style="color:black">function opt = dtd_pake_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dtd_pake_pipe(s, paths, opt)</b><br><div style="color:black">% s     - input structure</div><div style="color:black">% paths - either a pathname or a path structure (see mdm_paths)</div><div style="color:black">% opt   - (optional) options that drive the pipeline</div><div style="color:black">%</div><div style="color:black">% fn    - a cell arary with filenames to generated nii files</div><br><b style="color:black">function dtd_pake_plot(S, xps, h, h2)</b><br><br><h1 id="p13" style="background-color:black;color:white">&nbsp;Package: methods/fexi11</h1>Filter exchange imaging model. Requires DDE with variable mixing times.<br>Works best with powder averaged data.<br><br>Lasi? S, Nilsson M, L?tt J, St?hlberg F, Topgaard D (2011) Apparent <br>exchange rate mapping with diffusion MRI. Magn Reson Med 66(2):356?365.<br><br>Nilsson M, et al. (2013) Noninvasive mapping of water diffusional <br>exchange in the human brain using filter-exchange imaging. <br>Magn Reson Med 69(6):1573?1581.<br><br>Lampinen B, et al. (2016) Optimal experimental design for filter exchange <br>imaging: Apparent exchange rate measurements in the healthy brain and in <br>intracranial tumors. Magn Reson Med. doi:10.1002/mrm.26195.<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = fexi11_1d_data2fit(signal, xps, opt, ind)</b><br><div style="color:black">% Yields a 1xN vector 'm' with the fit parameters</div><div style="color:black">% m(1)   - ADC0</div><div style="color:black">% m(2)   - sigma</div><div style="color:black">% m(3)   - AXR</div><div style="color:black">% m(4:end) - vector of S0, length(m) = 3+max(s.xps.s_ind)</div><br><b style="color:black">function s = fexi11_1d_fit2data(m, xps)</b><br><br><b style="color:black">function mfs_fn = fexi11_4d_data2fit(s, o, opt)</b><br><div style="color:black">% Loops over a 4D volume to produce fit parameters with the FEXI nls model</div><div style="color:black">%</div><div style="color:black">% Input: </div><div style="color:black">%</div><div style="color:black">% s   - data structure</div><div style="color:black">%          s.nii_fn - full path to nifti filename with data</div><div style="color:black">%          s.xps    - experimental parameter structure</div><div style="color:black">%</div><div style="color:black">% o   - output folder   </div><div style="color:black">% </div><div style="color:black">% opt - options structure, optional</div><div style="color:black">%</div><div style="color:black">% Output:</div><div style="color:black">%</div><div style="color:black">% mfs_fn - path to .mat file with the ModelFitStructure (mfs)</div><br><b style="color:red">function fn = fexi11_nls_4d_fit2param(mfs_fn, o_path, opt)</b> (fexi11_4d_fit2param.m)<br><div style="color:black">% Creates meaningful parameters from the model fit structure</div><div style="color:black">%</div><div style="color:black">% Input:</div><div style="color:black">%</div><div style="color:black">% mfs_fn - Path to .mat file with model fit structure</div><div style="color:black">%</div><div style="color:black">% o_path - Output path, where parameters maps are stored</div><div style="color:black">%</div><div style="color:black">% opt    - Options, optional argument</div><div style="color:black">%</div><div style="color:black">%</div><div style="color:black">% Output:</div><div style="color:black">%</div><div style="color:black">% fn     - A cell array with paths to parameter maps that were written</div><div style="color:black">%</div><div style="color:black">% 2do: Update this function to agree with structure of dti_euler</div><br><b style="color:black">function fexi11_check_xps(xps)</b><br><div style="color:black">% checks that all required fields are found in the xps</div><br><b style="color:red">function fn = fexi11_invivo_pipeline(s, o_path, opt)</b> (fexi11_invivo_pipeline.m)<br><div style="color:black">% s      - input structure</div><div style="color:black">% o_path - output path</div><div style="color:black">% init stuff</div><br><b style="color:black">function opt = fexi11_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = ut_fexi11(c_ut)</b><br><div style="color:black">% if c_ut is not supplied, the function returns the number of unit tests</div><div style="color:black">% n_ut = number of unit tests</div><br><h1 id="p14" style="background-color:black;color:white">&nbsp;Package: methods/dtd_gamma</h1>Gamma model fit.<br><br>Does powder averaging<br><br>Lasic et al, Front. Phys. 2, 11 (2014).<br>http://dx.doi.org/10.3389/fphy.2014.00011<br><br>Modified for general b-tensor shapes<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = dtd_gamma_1d_data2fit(signal, xps, opt, ind)</b><br><div style="color:black">% m = [s0 d_iso mu2_iso mu2_aniso]</div><br><b style="color:black">function s = dtd_gamma_1d_fit2data(m, xps)</b><br><div style="color:black">% s0        = m(1);</div><div style="color:black">% d_iso     = m(2);</div><div style="color:black">% mu2_iso   = m(3);</div><div style="color:black">% mu2_aniso = m(4);</div><div style="color:black">% </div><div style="color:black">% convert to readable parameters</div><br><b style="color:black">function mfs_fn = dtd_gamma_4d_data2fit(s, mfs_fn, opt)</b><br><br><b style="color:black">function dps = dtd_gamma_4d_fit2param(mfs_fn, dps_fn, opt)</b><br><br><b style="color:black">function dtd_gamma_check_xps( xps )</b><br><br><b style="color:black">function opt = dtd_gamma_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dtd_gamma_pipe(s, paths, opt)</b><br><div style="color:black">% s     - input structure</div><div style="color:black">% paths - either a pathname or a path structure (see mdm_paths)</div><div style="color:black">% opt   - (optional) options that drive the pipeline</div><div style="color:black">%</div><div style="color:black">% fn    - a cell arary with filenames to generated nii files</div><div style="color:black">%</div><div style="color:black">% Gamma fit</div><div style="color:black">% Does powder averaging</div><div style="color:black">% Lasic et al, Front. Phys. 2, 11 (2014).</div><div style="color:black">% http://dx.doi.org/10.3389/fphy.2014.00011</div><div style="color:black">% Modified for general b-tensor shapes</div><br><b style="color:black">function dtd_gamma_plot(S, xps, h, h2)</b><br><br><h1 id="p15" style="background-color:black;color:white">&nbsp;Package: methods/quick_dti</h1>Quick DTI fitting using least squares fitting without adjusting for<br>heteroscedasticity.<h2 style="background-color:#dddddd">Functions</h2><b style="color:red">function m = dti_1d_data2fit(signal, xp, opt)</b> (qdti_1d_data2fit.m)<br><br><b style="color:red">function p = dti_1d_fit2param(m, xp, opt, signal)</b> (qdti_1d_fit2param.m)<br><br><br><b style="color:red">function mfs_fn = qdti_4d_data2fit(s, o, opt)</b> (qdti_4d_data2fit.m)<br><br><b style="color:black">function fn = qdti_4d_fit2param(mfs_fn, o_path, opt)</b><br><div style="color:black">% 2do: Update this function to agree with structure of dti_euler</div><br><b style="color:black">function opt = qdti_opt(opt)</b><br><br><b style="color:red">function fn = qdti_pipe_example(s, o_path, opt)</b> (qdti_pipe_example.m)<br><div style="color:black">% s      - input structure</div><div style="color:black">% o_path - output path</div><br><b style="color:red">function status = ut_qdti(c_ut)</b> (ut_qdti.m)<br><div style="color:black">% n_ut = number of unit tests</div><br><h1 id="p16" style="background-color:black;color:white">&nbsp;Package: methods/dtd_saupe</h1><h2 style="background-color:#dddddd">Functions</h2><b style="color:red">function dps_fn = dtd_saupe_4d_fit2param(mfs_fns, dps_fn, opt)</b> (dtd_saupe_4d_fit2param.m)<br><div style="color:black">% Saupe order tensor imaging</div><div style="color:black">% Combination of DTI, gamma, and erf</div><div style="color:black">% Topgaard, Phys. Chem. Chem. Phys. (2016).</div><div style="color:black">% http://dx.doi.org/10.1039/c5cp07251d</div><br><b style="color:black">function opt = dtd_saupe_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = dtd_saupe_pipe(s, paths, opt)</b><br><br><h1 id="p17" style="background-color:black;color:white">&nbsp;Package: methods/vasco16</h1>VascoPule model. Aim is to extract the blood fraction by the use of two<br>datasets obtained with and without flow compensation (stored in xps.alpha2)<br><br>This model is described in Ahlgren et al. (2016) NMR Biomed. <br><br>WARNING: This code is note yet verified. It is not the same code as<br>was used in the Ahlgren et al paper. <h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function m = vasco16_1d_data2fit(signal, xps, opt, ind)</b><br><br><b style="color:black">function s = vasco16_1d_fit2data(m, xps)</b><br><div style="color:black">% convert to readable parameters</div><br><b style="color:black">function mfs_fn = vasco16_4d_data2fit(s, o, opt)</b><br><br><b style="color:black">function fn = vasco16_4d_fit2param(mfs_fn, o_path, opt)</b><br><div style="color:black">% 2do: Update this function to agree with structure of dti_euler</div><br><b style="color:black">function vasco16_check_xps(xps)</b><br><br><b style="color:black">function opt = vasco16_opt(opt)</b><br><div style="color:black">% Makes sure that all needed fields in the options structure are present</div><br><b style="color:black">function fn = vasco16_pipeline(s, o_path, opt)</b><br><div style="color:black">% unit of v2 seems wrong</div><div style="color:black">% calculation of alpha must be checked</div><br><b style="color:black">function vasco16_plot(S, xps, h, h2)</b><br><br><h1 id="p18" style="background-color:black;color:white">&nbsp;Package: tools</h1>This folder contains various tools that are useful in the context of<br>designing or analysing multidimensional dMRI data, e.g.,  math-related <br>functions.<br><br><h1 id="p19" style="background-color:black;color:white">&nbsp;Package: tools/tensor_maths</h1>Functions for transforming first, second, and fourth-order tensors. <br>The functions were used extensively in the following papers:<br><br>Westin CF, et al (2016). "Q-space trajectory imaging for multidimensional <br>diffusion MRI of the human brain". NeuroImage.<br><br>Westin CF, et al. (2014) "Measurement Tensors in Diffusion MRI: <br>Generalizing the Concept of Diffusion Encoding." <br>Med Image Comput Comput Assist Interv 8675:209?216.<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function t = tm_1x15_to_6x6(N)</b><br><div style="color:black">% Converts a fourth-order tensor on the 1x15 format to the 6x6 format</div><br><b style="color:black">function [E_bulk, E_shear, E2_iso] = tm_1x21_iso()</b><br><div style="color:black">% Obtain the isotropic fourth-order tensors in the 1x21 Voigt-like format</div><br><b style="color:black">function t = tm_1x21_to_6x6(t)</b><br><div style="color:black">% Convert fourth-order tensor in 1x21 format to 6x6 format</div><br><b style="color:black">function t = tm_1x3_to_1x15(N)</b><br><div style="color:black">% Convert a vector in 1x3 format to a fourth-order tensor in 1x15 format</div><br><b style="color:black">function t = tm_1x3_to_1x6(ad, rd, n)</b><br><div style="color:black">% Convert a vector (1x3) to a tensor (1x6), but enable some shaping of the</div><div style="color:black">% tensor, so that its longest eigenvalue is 'ad' and its shortest to </div><div style="color:black">% eigenvalues are 'rd'</div><br><b style="color:black">function [L, v_1] = tm_1x6_eigvals(v_1x6, c_method)</b><br><div style="color:black">%</div><div style="color:black">% c_method</div><div style="color:black">%   1 - Cardano's fast method</div><div style="color:black">%   2 - eigs in Matlab</div><br><b style="color:black">function t = tm_1x6_to_1x21(n2)</b><br><div style="color:black">% Convert a second-order tensor on Voigt notation (1x6) to a </div><div style="color:black">% fourth-order tensor in Voight-like notation (1x21). This correspons</div><div style="color:black">% to taking the outer product of 'n2'</div><br><b style="color:black">function t = tm_1x6_to_1x56(B2)</b><br><div style="color:black">% Take the third outer product of B2, making the outcome a sixth order</div><div style="color:black">% tensor</div><br><b style="color:black">function t = tm_1x6_to_3x3(t)</b><br><div style="color:black">% convert a second order tensor from Voigt format to 3x3 matrix format</div><br><b style="color:black">function t = tm_1x6_to_tpars(t_1x6)</b><br><br><b style="color:black">function t = tm_2d_1x2_to_1x3(ad, rd, n)</b><br><div style="color:black">% Two-dimensional version of tm_1x3_to_1x6</div><br><b style="color:black">function t = tm_2d_1x3_to_1x6(t)</b><br><div style="color:black">% Two-dimensional version of tm_1x6_to_1x21</div><br><b style="color:black">function t = tm_2d_1x3_to_2x2(t)</b><br><div style="color:black">% Two-dimensional version of tm_1x6_to_3x3</div><br><b style="color:black">function t = tm_2d_1x6_to_3x3(t)</b><br><div style="color:black">% Two-dimensional version of tm_1x21_to_6x6</div><br><b style="color:black">function E_iso = tm_3x3_iso()</b><br><div style="color:black">% Get the isotropic 3x3 tensor</div><br><b style="color:black">function t = tm_3x3_to_1x6(t)</b><br><div style="color:black">% Convert a second-order 3x3 tensor to  Voigtm-format 1x6</div><br><b style="color:black">function t = tm_3x3_to_tpars(t3x3)</b><br><div style="color:black">% calculate derived tensor parameters</div><br><b style="color:black">function [E_bulk, E_shear, E2_iso] = tm_6x6_iso()</b><br><div style="color:black">% Get the three different isotropic fourth-order tensors</div><br><b style="color:black">function t = tm_6x6_to_1x15(N)</b><br><div style="color:black">% Convert a 6x6 tensor to a Voigt-like 1x15 representation</div><div style="color:black">% Warning: degrees of freedom are lost in this conversion.</div><br><b style="color:black">function t = tm_6x6_to_1x21(t)</b><br><div style="color:black">% Convert a fourth-order tensor on the 6x6 format to a Voigt-like format</div><br><b style="color:black">function t_nx6 = tm_ax2nx6(par,perp,theta,phi)</b><br><div style="color:black">% Produce a set of 1x6 tensors from parallel and perpendicular </div><div style="color:black">% eigenvalues, plus theta and phi angles of the parallel part</div><br><b style="color:black">function [rotmat,rotmatinv] = tm_euler_angles2rotmat(alpha,beta,gamma)</b><br><div style="color:black">% Active right-handed rotation</div><div style="color:black">% First gamma around z, then beta around y, and finally alpha around z</div><div style="color:black">% Input must be scalars.</div><br><b style="color:black">function fa = tm_fa(a,b)</b><br><div style="color:black">% With one input argumnet: calculate the FA of the second order tensor 'a'</div><div style="color:black">% With two arguments: assume 'a' to be MD and 'b' to be the variance in</div><div style="color:black">%           eigenvectors, and calculate FA from that</div><br><b style="color:black">function x = tm_inner(x,y)</b><br><div style="color:black">% Take the inner product of 'x' and 'y'.</div><div style="color:black">% However, rewrite required</div><br><b style="color:black">function md = tm_md(d2)</b><br><div style="color:black">% Calculate the mean diffusivity of the second-order tensor 'd2'</div><br><b style="color:black">function x = tm_outer(x,y)</b><br><div style="color:black">% Take the outer product of 'x' and 'y'</div><br><b style="color:black">function t = tm_t2tpars(t3x3)</b><br><div style="color:black">% calculate derived tensor parameters</div><br><b style="color:black">function v_lambda = tm_v_lambda(d2)</b><br><div style="color:black">% Calculate the eigenvalue variance of the second-order tensor in 'd2'</div><br><b style="color:black">function fn = ut_tensor_maths(c_ut)</b><br><div style="color:black">% if c_ut is not supplied, the function returns the number of unit tests</div><div style="color:black">% </div><div style="color:black">% n_ut = number of unit tests</div><br><h1 id="p20" style="background-color:black;color:white">&nbsp;Package: tools/uvec</h1>Functions to generate/retrieve set of vectors<h2 style="background-color:#dddddd">Functions</h2><b style="color:black">function fn = ut_uvec(c_ut)</b><br><div style="color:black">% if c_ut is not supplied, the function returns the number of unit tests</div><div style="color:black">% n_ut = number of unit tests</div><br><b style="color:black">function u = uvec_dodeca()</b><br><div style="color:black">% Optimal dodeca direction set</div><br><b style="color:black">function [u, phi,theta] = uvec_elstat(n)</b><br><div style="color:black">% Loads electrostatically optimized angles for n = 10-1000</div><br><b style="color:black">function u = uvec_icosa()</b><br><div style="color:black">% Returns an optimal icosahedral direction set</div><br><b style="color:black">function u = uvec_tricosa()</b><br><div style="color:black">% Truncated icosa direction set</div><br></body></html>